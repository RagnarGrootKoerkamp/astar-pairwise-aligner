#+TITLE: Todo

List of TODOs and other quick remarks.

* Correctness
** DONE Proof for consistency of $h$ at start of matches
** TODO Proof that =consistent pruned heuristics= works
A lowerbound on the shortest path to the end, not using any already expanded
states. Consistent when $f$ never decreases over edges.
** TODO Proof that pruning heuristic yields a consistent pruned heuristic

* Analysis
** TODO What is the expected deviation from the diagonal for a random sequence?
Is this $sqrt(n)$ like in a drunkard's walk? Or is it less, because we know
where we end and can use $j = (m/n) * i$ as prediction.

* Failing assertions / Bugs
** DONE Investigate inconsistent heuristic before pruning
CLOSED: [2022-01-22 Sat 23:05]
For n=300000 e=0.2, the assertion failed at least once.
Also found counterexamples for n=100.

Fixed by the point below.
** DONE Fix consistency of pruning with shadow points
CLOSED: [2022-01-22 Sat 23:05]
When a point is removed from a layer, dependent dominant points in the next
layer need to be checked, because they may need to be inserted in the current
layer as new shadow points. It is unclear to me why this hasn't been an issue
for NaiveContours so for, but only shown up for HintContours.

Fixed by for each point that is up to date in the prune callback, checking
whether shadow points need to be added after pruning on the layer below.
** DONE Pruning may result in double expansion of matches
CLOSED: [2022-01-11 Tue 14:21]
We have to make sure that we only prune when we found the shortest path to a
node. Currently this assertion fails, probably because of issues around pruning
inexact matches next to exact matches.

It seems that this is not an issue anymore when retrying on outdated heuristic values.

** DONE GappedSeedHeuristic differs from SeedHeuristic in some edge cases
CLOSED: [2022-01-11 Tue 16:28]
SeedHeuristic was using outdated values of h when rebuilding, leading to differences.
** DONE Do we need some special consideration for seeds exactly on the edge of the cone region?
CLOSED: [2022-01-11 Tue 16:28]
Nope, fixed by the above
** DONE NaiveContours sometimes drops values by more than max_len.
CLOSED: [2022-01-11 Tue 14:23]
Fixed by replacing the pruning of the single root point by also
pruning silently pruned potential new dominant points in the layer.

** DONE Make sure SeedHeuristic never uses the GapCost.
CLOSED: [2022-01-11 Tue 20:34]
In the GapSeedHeuristic, we never use a gap distance, unless it's towards the target.
This test makes sure that SeedHeuristic<Gap> does the same:
Instead of taking max(gap distance, potential distance), in cases when gap >
potential, this parent should be skipped completely.
** DONE Double expanding start of seeds
CLOSED: [2022-01-12 Wed 11:28]
*** Broken solution
Disabled greedy matching. Removing multiple types of not-best paths can lead
to deletion of all best paths, since we don't have a strict inequality.
In particular, greedy matching can lead to a non-consistent heuristic.

Even with greedy matching disabled, that doesn't mean this problem won't happen
anymore.
Solutions:
- Do not prune matches where the cell above/below it has a lower value, as that
  would lead to an inconsistent heuristic.
- Argue that the current situation is fine. That may or may not be true, and
  likely depends on the order in which the A* breaks ties between equal $f$ values.
*** Good solution
Re-enabled greedy matching -- that was not the problem.

Instead, we have to make sure that even after pruning $h$ remains consistent.
If we have a situation where we prune a position with $h$ larger than a
neighbour above or below, after pruning this difference will be at least $2$,
which is not consistent.

As a fix, both ~SeedHeuristic~ and ~GapSeedHeuristic~ now check whether the
current $h$ value is larger than any of the neighbours above/below, and if so,
skip pruning.

* Statistics
** TODO avg total estimated distance
** TODO max number of consecutive matches
** TODO contribution to h from matches and distance heuristic
** TODO heuristic time
** TODO number of skipped matches
** DONE pruning time
CLOSED: [2022-01-13 Thu 18:56]
** TODO Use ~explored/path-len~ for band, instead of ~explored/max(n,m)~

* Code
** TODO fuzzing/testing that fast impls equal slow impls
** TODO efficient pruning: skip explored states that have outdated heuristic value (aka pruning with offset)
** DONE Investigate doing long jumps on matching diagonals.
CLOSED: [2022-01-15 Sat 17:19]
Did not give much, because A* will expand jumped-over states anyway.
** TODO Rename max_match_cost to something that includes the +1 that's present everywhere.
** DONE Make a separate type for transformed positions
CLOSED: [2022-01-19 Wed 18:02]
** DONE Parameter for enabling greedy matching
CLOSED: [2022-01-19 Wed 18:02]
** DONE Remove sorting from BucketHeap? (Doesn't matter for A*, but may help for cache locality.)
CLOSED: [2022-01-19 Wed 18:02]
** DONE Colour ~print_heuristic~ by contours instead of by parent.
CLOSED: [2022-01-15 Sat 17:18]
** TODO Consider using Intrusive Collections for storing contours.
This is not going to be helpful now that contours are typically very small.
** TODO Check code coverage to see which edge cases are never hit.
** DONE Extract tests to /tests.
CLOSED: [2022-01-19 Wed 18:03]
** TODO Replace ~Sequence: Vec<u8>~ by ~&[u8]~.
** TODO Test if ~dyn Contour~ is as fast as ~C: Contour~, and if so simplify the code this way.
Same for Heuristic. Compilation is very slow after enumerating over all possible
implementations in ~algorithms.rs~.
** TODO Trie for inexact matching
WIP, but not so efficient yet.
*** TODO Instead of a Vec<> in each node, make one big vec of data pointers
*** TODO Insert words in sorted order
- Cache locality
- data can be a slice from larger vector.

** DONE Shrink size of Pos
CLOSED: [2022-01-15 Sat 17:18]
** DONE Add new strong type for costs.
CLOSED: [2022-01-15 Sat 17:18]
** TODO More compact Match/Arrow representation; using delta encoding for end
** TODO Parallelize code
*** TODO Trie building (lock after the first 2 layers)
*** TODO Trie lookup: trie is immutable at this point
*** TODO A*: One thread for pruning, one thread for querying
** TODO A*:
*** DONE Instead of storing f for expanded states, store g for queue states
CLOSED: [2022-01-21 Fri 03:24]
Only process if f is up-to-date and g_queue == g_expanded

Not much speedup, but fixes a potential bug because checking ~f_queue < f~ isn't
always accurate in context of pruning.
Double-expands slightly more now, but retries much less, because the check for
~g_queue == g~ (which just ignores the element if false), makes for skipping
some retries.
*** DONE Optimize for matching states: process these directly instead of pushing & popping from the queue
CLOSED: [2022-01-21 Fri 02:45]
This gives up to 2x speedup of the A* for highly similar sequences.
** DONE Fix timing of pruning
CLOSED: [2022-01-21 Fri 15:50]
Currently it often reports 0, even though it's much more in the flamegraph.
** TODO Make deleting from ~contours~ vector faster
Replace the single vector by something that allows faster deletion but still
constant time lookup. Maybe something using sqrt decomposition or fenwick trees.
Or maybe soft-deletion in combination with something with Union-Find, where each
original contour points to the contour it merged into.

* Tests
** TODO Test all pairs with n <= 6

* Extensions
** LCS: Do not generate substitutions
** MSA (delayed; pruning complications)
*** TODO instantiate one heuristic per pair of sequences
*** TODO run A* on the one-by-one step graph
** Non-constant indel/substitution cost
** Affine gaps
*** Git-diff, but better?


* Edit Distance
** TODO Run SeedHeuristic with k=1 as edit distance computation algorithm.
- This generalizes the LCS Contours algorithm to edit distance.
- For k>1, it generalizes the LCS_{k[+]}  algorithm and provides a lower bound.

* Seeds
** TODO Dynamic seeding, either greedy or using some DP[i, j, distance].
- Maximize h(0,0) or (max_match_cost+1)/k
- Minimize number of extra seeds.
** TODO choosing seeds bases on guessed alignment
** TODO Fix the gap heuristic transpose to take the seeds into account.
** DONE Strategies for choosing seeds:
CLOSED: [2022-01-19 Wed 18:01]
- A: Each seed does not match, and covers exactly max_dist+1 mutations.
  - This way, no pruning is needed because there are no matches on the
    diagonal, and h(0,0) exactly equals the actual distance, so that only a
    very narrow region is expanded.
- B: Maximize the number of seeds that matches exactly (at most 10 times).
- Experiment: make one mutation every k positions, and make seeds of length k.
** TODO Try SeedHeuristic without Gaps
- Maybe now that we have pruning, gaps aren't actually needed anymore.
** TODO Instead of finding all matches and then filtering, only find matches within the cone
- Could be done by keeping a dynamic trie, only inserting positions in b once
  they fall within the cone, and removing then as soon as they leave the cone again.

* Pruning
** TODO In-place bruteforce pruning for IncreasingFunction datastructure
** TODO Partial pruning: only prune matches where it is cheap to do so
** TODO Proof that pruning doesn't interact badly with consistency
** TODO Implementation for fast partial pruning:
- If the current match has no prev/next on the pareto front, *all* previous points must have optimal paths through this match.
- Removing this match decreases h for *all* previous matches
- Either bruteforce decrement the value at previous nodes, or keep some log-time datastructure for this.
- Most of the time, the match will be at the very front and there are going
  to be very few expanded states in front, so we can do an offset and only
  update h for those expanded states beyond this match.
** TODO Pruning with offset
- Need to figure out when all previous vertices depend on the current match
** TODO Remove matches from indels at the start and ends of seeds. Replace by doing a wider lookup along the diagonal.
** TODO Don't only query the current point, but also points above/below it
- to correct for small differences between heuristic implementations.
** TODO Banded pruning
only prune and update matches within $\sqrt n$ of the main diagonal. The rest
won't be relevant anyway.
** TODO More greedy pruning of matches that were skipped initially because of their neighbours.
If we skip because there is a higher valued neighbour, then when pruning that
neighbour, the original should also be pruned.

** NOTE Pruning of inexact matches has differences between the bruteforce and contour algorithm:
- In the bruteforce, when an exact match is pruned, neighbouring exact matches
  can still be used. Thus, the pruning only affects one state.
- Using contours, more states get an increased value, because for states
  'before' the pruned inexact match, going through the exact match is never
  optimal to begin with. This leads to non-equal heuristic values between the
  two approaches, but not to an inadmissible heuristic.

* Performance
** DONE Use Pos(u32,u32) instead of Pos(usize,usize)
CLOSED: [2022-01-19 Wed 18:00]
** TODO Use array + sorting + binary search to find optimal path.
** DONE Do Greedy extending of edges along diagonals
Whenever a state $(i,j)$ has a matching outgoing edge, we only generate
$(i,j) \to (i+1, j+1)$ and skip the indel edges.
** TODO Skip insertions at the start/end of seeds.
** DONE Prune only half (some fixed %) of matches. This should result in O(matches) total pruning time.
CLOSED: [2022-01-19 Wed 18:00]
** TODO Prune only matches at (or close to) the 'front': with so far maximal i and j, for not having to update the priority queue.
** TODO Do not generate dist-1 matches with insertions at the start and/or end.
** TODO Do not generate dist-1 matches with deletions at the end.
   - Can deletions at the start also be pruned? It may screw up heuristic values right next to it. Does that matter?
   - Definitely cannot skip deletions at both start and end.
** TODO Replace IncreasingFunction by a vector: value -> position, instead of the current position->value map.
   This is sufficient, because values only increase by 1 or 2 at a time anyway, and set lookup becomes binary search.
** TODO ContourGraph: Add child pointer to incremental state, for faster moving diagonally.
** TODO Investigate gap between h(0,0) and the actual distance.
   - For exact matches, do we want exactly 1 mutation per seed? That way h(0,0) is as large as possible, and we don't have any matches.
** TODO When building ContourGraphs, to get the value at the end of a match,
   instead of walking there using incremental steps, compute and store the value
   of the match once then end-column is processed, but insert it only when the
   start-column is being processed.
** TODO Use SuffixArray instead of multiple QGramIndices for fixed k.
** TODO Update ContourGraph to set the value of a match after processing the end-column, instead of doing a lookup when processing the start column.

* DONE Fast Seed+Gap heuristic implementation:
** Bruteforce from bottom right to top left, fully processing everything all
   matches that are 'shadowed', i.e. only matter for going left/up, but not diagonally anymore.

* Optimizations done:
** Seed Heuristic
** Count Heuristic
** Inexact matches
** Pruning
** sort nodes closer to target first, among those with equal distance+h estimate
   - this almost halves the part of the bandwidth above 1.
** Pruning correctness: Do not prune matches that are next to a better match.
** A* optimizations: together 4x speedup
   - HashMap -> FxHashMap: a faster hash function for ints
   - HashMap -> DiagonalMap: for expanded/explored states, since these are dense on the diagonal.
   - BinaryHeap -> BucketHeap: much much faster; turns log(n) pop into O(1) push&pop
     - For unknown reasons, sorting positions before popping them makes more expanded states, but faster code.
** delete consistency code
** delete incoming edges code
** more efficient edges iteration
** Pre-allocate DiagonalMap edges
** Do internal iteration over outgoing edges, instead of collecting them.
** Sort nodes in IncreasingFunction for better caching
** incremental_h is slowly becoming more efficient (move fewer steps backwards)
** incremental_h: Add Pos==Hint check to incremental_h

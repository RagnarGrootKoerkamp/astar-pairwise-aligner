#+TITLE: Todo

List of TODOs and other quick remarks.

* Correctness
** DONE Proof for consistency of $h$ at start of matches
** TODO Proof that =consistent pruned heuristics= works
A lowerbound on the shortest path to the end, not using any already expanded
states. Consistent when $f$ never decreases over edges.
** TODO Proof that pruning heuristic yields a consistent pruned heuristic

* Analysis
** TODO What is the expected deviation from the diagonal for a random sequence?
Is this $sqrt(n)$ like in a drunkard's walk? Or is it less, because we know
where we end and can use $j = (m/n) * i$ as prediction.

* Failing assertions / Bugs
** TODO Investigate inconsistent heuristic before pruning
For n=300000 e=0.2, the assertion failed at least once.
Also found counterexamples for n=100.
** DONE Pruning may result in double expansion of matches
CLOSED: [2022-01-11 Tue 14:21]
We have to make sure that we only prune when we found the shortest path to a
node. Currently this assertion fails, probably because of issues around pruning
inexact matches next to exact matches.

It seems that this is not an issue anymore when retrying on outdated heuristic values.

** DONE GappedSeedHeuristic differs from SeedHeuristic in some edge cases
CLOSED: [2022-01-11 Tue 16:28]
SeedHeuristic was using outdated values of h when rebuilding, leading to differences.
** DONE Do we need some special consideration for seeds exactly on the edge of the cone region?
CLOSED: [2022-01-11 Tue 16:28]
Nope, fixed by the above
** DONE NaiveContours sometimes drops values by more than max_len.
CLOSED: [2022-01-11 Tue 14:23]
Fixed by replacing the pruning of the single root point by also
pruning silently pruned potential new dominant points in the layer.

** DONE Make sure SeedHeuristic never uses the GapCost.
CLOSED: [2022-01-11 Tue 20:34]
In the GapSeedHeuristic, we never use a gap distance, unless it's towards the target.
This test makes sure that SeedHeuristic<Gap> does the same:
Instead of taking max(gap distance, potential distance), in cases when gap >
potential, this parent should be skipped completely.
** DONE Double expanding start of seeds
CLOSED: [2022-01-12 Wed 11:28]
*** Broken solution
Disabled greedy matching. Removing multiple types of not-best paths can lead
to deletion of all best paths, since we don't have a strict inequality.
In particular, greedy matching can lead to a non-consistent heuristic.

Even with greedy matching disabled, that doesn't mean this problem won't happen
anymore.
Solutions:
- Do not prune matches where the cell above/below it has a lower value, as that
  would lead to an inconsistent heuristic.
- Argue that the current situation is fine. That may or may not be true, and
  likely depends on the order in which the A* breaks ties between equal $f$ values.
*** Good solution
Re-enabled greedy matching -- that was not the problem.

Instead, we have to make sure that even after pruning $h$ remains consistent.
If we have a situation where we prune a position with $h$ larger than a
neighbour above or below, after pruning this difference will be at least $2$,
which is not consistent.

As a fix, both ~SeedHeuristic~ and ~GapSeedHeuristic~ now check whether the
current $h$ value is larger than any of the neighbours above/below, and if so,
skip pruning.

* Statistics
** TODO avg total estimated distance
** TODO max number of consecutive matches
** TODO contribution to h from matches and distance heuristic
** TODO heuristic time
** TODO number of skipped matches
** DONE pruning time
CLOSED: [2022-01-13 Thu 18:56]
** TODO Use ~explored/path-len~ for band, instead of ~explored/max(n,m)~

* Code
** TODO fuzzing/testing that fast impls equal slow impls
** TODO efficient pruning: skip explored states that have outdated heuristic value (aka pruning with offset)
** TODO Investigate doing long jumps on matching diagonals.
** TODO Rename max_match_cost to something that includes the +1 that's present everywhere.
** TODO Make a separate type for transformed positions
** TODO Parameter for enabling greedy matching
** TODO Remove sorting from BucketHeap? (Doesn't matter for A*, but may help for cache locality.)
** TODO Colour ~print_heuristic~ by contours instead of by parent.
** TODO Consider using Intrusive Collections for storing contours.
** TODO Check code coverage to see which edge cases are never hit.
** TODO Extract tests to /tests.
** TODO Replace ~Sequence: Vec<u8>~ by ~&[u8]~.
** TODO Test if ~dyn Contour~ is as fast as ~C: Contour~, and if so simplify the code this way.
Same for Heuristic. Compilation is very slow after enumerating over all possible
implementations in ~algorithms.rs~.

* Tests
** TODO Test all pairs with n <= 6

* Extensions
** MSA (delayed; pruning complications)
*** TODO instantiate one heuristic per pair of sequences
*** TODO run A* on the one-by-one step graph
** Non-constant indel/substitution cost
** Affine gaps

* Edit Distance
** TODO Run SeedHeuristic with l=1 as edit distance computation algorithm.
- This generalizes the LCS Contours algorithm to edit distance.
- For l>1, it generalizes the LCS_{k[+]}  algorithm and provides a lower bound.

* Seeds
** TODO Dynamic seeding, either greedy or using some DP[i, j, distance].
- Maximize h(0,0) or (max_match_cost+1)/l
- Minimize number of extra seeds.
** TODO choosing seeds bases on guessed alignment
** TODO Fix the gap heuristic transpose to take the seeds into account.
** TODO Strategies for choosing seeds:
- A: Each seed does not match, and covers exactly max_dist+1 mutations.
  - This way, no pruning is needed because there are no matches on the
    diagonal, and h(0,0) exactly equals the actual distance, so that only a
    very narrow region is expanded.
- B: Maximize the number of seeds that matches exactly (at most 10 times).
- Experiment: make one mutation every l positions, and make seeds of length l.
** TODO Try SeedHeuristic without Gaps
- Maybe now that we have pruning, gaps aren't actually needed anymore.

* Pruning
** TODO In-place bruteforce pruning for IncreasingFunction datastructure
** TODO Partial pruning: only prune matches where it is cheap to do so
** TODO Proof that pruning doesn't interact badly with consistency
** TODO Implementation for fast partial pruning:
- If the current match has no prev/next on the pareto front, *all* previous points must have optimal paths through this match.
- Removing this match decreases h for *all* previous matches
- Either bruteforce decrement the value at previous nodes, or keep some log-time datastructure for this.
- Most of the time, the match will be at the very front and there are going
  to be very few expanded states in front, so we can do an offset and only
  update h for those expanded states beyond this match.
** TODO Pruning with offset
- Need to figure out when all previous vertices depend on the current match
** TODO Remove matches from indels at the start and ends of seeds. Replace by doing a wider lookup along the diagonal.
** TODO Don't only query the current point, but also points above/below it
- to correct for small differences between heuristic implementations.
** TODO Banded pruning
only prune and update matches within $\sqrt n$ of the main diagonal. The rest
won't be relevant anyway.

** NOTE Pruning of inexact matches has differences between the bruteforce and contour algorithm:
- In the bruteforce, when an exact match is pruned, neighbouring exact matches
  can still be used. Thus, the pruning only affects one state.
- Using contours, more states get an increased value, because for states
  'before' the pruned inexact match, going through the exact match is never
  optimal to begin with. This leads to non-equal heuristic values between the
  two approaches, but not to an inadmissible heuristic.

* Performance
** TODO Use Pos(u32,u32) instead of Pos(usize,usize)
** TODO Use array + sorting + binary search to find optimal path.
** DONE Do Greedy extending of edges along diagonals
Whenever a state $(i,j)$ has a matching outgoing edge, we only generate
$(i,j) \to (i+1, j+1)$ and skip the indel edges.
** TODO Skip insertions at the start/end of seeds.
** TODO Prune only half (some fixed %) of matches. This should result in O(matches) total pruning time.
** TODO Prune only matches at (or close to) the 'front': with so far maximal i and j, for not having to update the priority queue.
** TODO Do not generate dist-1 matches with insertions at the start and/or end.
** TODO Do not generate dist-1 matches with deletions at the end.
   - Can deletions at the start also be pruned? It may screw up heuristic values right next to it. Does that matter?
   - Definitely cannot skip deletions at both start and end.
** TODO Replace IncreasingFunction by a vector: value -> position, instead of the current position->value map.
   This is sufficient, because values only increase by 1 or 2 at a time anyway, and set lookup becomes binary search.
** TODO ContourGraph: Add child pointer to incremental state, for faster moving diagonally.
** TODO Investigate gap between h(0,0) and the actual distance.
   - For exact matches, do we want exactly 1 mutation per seed? That way h(0,0) is as large as possible, and we don't have any matches.
** TODO When building ContourGraphs, to get the value at the end of a match,
   instead of walking there using incremental steps, compute and store the value
   of the match once then end-column is processed, but insert it only when the
   start-column is being processed.
** TODO Use SuffixArray instead of multiple QGramIndices for fixed l.
** TODO Update ContourGraph to set the value of a match after processing the end-column, instead of doing a lookup when processing the start column.

* DONE Fast Seed+Gap heuristic implementation:
** Bruteforce from bottom right to top left, fully processing everything all
   matches that are 'shadowed', i.e. only matter for going left/up, but not diagonally anymore.

* Optimizations done:
** Seed Heuristic
** Count Heuristic
** Inexact matches
** Pruning
** sort nodes closer to target first, among those with equal distance+h estimate
   - this almost halves the part of the bandwidth above 1.
** Pruning correctness: Do not prune matches that are next to a better match.
** A* optimizations: together 4x speedup
   - HashMap -> FxHashMap: a faster hash function for ints
   - HashMap -> DiagonalMap: for expanded/explored states, since these are dense on the diagonal.
   - BinaryHeap -> BucketHeap: much much faster; turns log(n) pop into O(1) push&pop
     - For unknown reasons, sorting positions before popping them makes more expanded states, but faster code.
** delete consistency code
** delete incoming edges code
** more efficient edges iteration
** Pre-allocate DiagonalMap edges
** Do internal iteration over outgoing edges, instead of collecting them.
** Sort nodes in IncreasingFunction for better caching
** incremental_h is slowly becoming more efficient (move fewer steps backwards)
** incremental_h: Add Pos==Hint check to incremental_h
